# Python Programming Best Practices

## Code Style and Formatting

### PEP 8 Guidelines

Python's official style guide, PEP 8, recommends:

- Use 4 spaces for indentation (not tabs)
- Limit lines to 79 characters for code, 72 for comments
- Use blank lines to separate functions and classes
- Use meaningful variable and function names
- Write docstrings for all public modules, functions, classes, and methods

### Naming Conventions

Python naming conventions include:

- **Variables and functions**: Use lowercase with underscores (snake_case)
  - Example: `user_name`, `calculate_total()`
- **Classes**: Use CamelCase (CapitalizedWords)
  - Example: `UserAccount`, `DataProcessor`
- **Constants**: Use uppercase with underscores
  - Example: `MAX_CONNECTIONS`, `API_KEY`
- **Private members**: Prefix with underscore
  - Example: `_internal_method`, `_private_variable`

## Writing Clean Code

### Functions

Good function practices:

1. Keep functions small and focused on one task
2. Use descriptive names that indicate what the function does
3. Limit the number of parameters (ideally 3 or fewer)
4. Return early to avoid deep nesting
5. Use type hints for clarity

Example:
```python
def calculate_discount(price: float, discount_percent: float) -> float:
    """Calculate the discounted price.
    
    Args:
        price: Original price of the item
        discount_percent: Discount percentage (0-100)
    
    Returns:
        The price after applying the discount
    """
    if discount_percent < 0 or discount_percent > 100:
        raise ValueError("Discount must be between 0 and 100")
    
    discount_amount = price * (discount_percent / 100)
    return price - discount_amount
```

### Error Handling

Best practices for exception handling:

- Catch specific exceptions, not generic Exception
- Use try-except blocks sparingly
- Always clean up resources (use context managers)
- Provide informative error messages
- Log exceptions appropriately

Example:
```python
try:
    with open(filename, 'r') as file:
        data = file.read()
except FileNotFoundError:
    logger.error(f"File not found: {filename}")
    raise
except PermissionError:
    logger.error(f"Permission denied: {filename}")
    raise
```

## Testing

### Unit Testing

Write comprehensive unit tests:

- Test one thing per test function
- Use descriptive test names
- Follow the Arrange-Act-Assert pattern
- Test edge cases and error conditions
- Aim for high code coverage

### Test Frameworks

Popular Python testing frameworks:

- **pytest**: Most popular, feature-rich
- **unittest**: Built into Python standard library
- **nose2**: Extends unittest
- **hypothesis**: Property-based testing

## Documentation

### Docstrings

Write clear docstrings:

- Use Google or NumPy style docstrings
- Document parameters, return values, and exceptions
- Include usage examples for complex functions
- Keep docstrings up to date with code changes

### Type Hints

Use type hints for better code clarity:

```python
from typing import List, Dict, Optional

def process_users(users: List[Dict[str, str]], 
                  admin_only: bool = False) -> Optional[List[str]]:
    """Process a list of users and return their names."""
    pass
```

## Performance Optimization

### Profiling

Profile before optimizing:

- Use cProfile for CPU profiling
- Use memory_profiler for memory usage
- Identify actual bottlenecks before optimizing
- Measure performance improvements

### Common Optimizations

- Use list comprehensions instead of loops when appropriate
- Use generators for large data processing
- Choose appropriate data structures (dict for lookups, set for membership)
- Use built-in functions (they're often faster)
- Consider using NumPy for numerical operations

## Security Best Practices

### Input Validation

Always validate user input:

- Sanitize inputs to prevent injection attacks
- Validate data types and ranges
- Use parameterized queries for databases
- Never trust user input

### Secrets Management

Handle secrets properly:

- Never hardcode secrets in source code
- Use environment variables or secret managers
- Don't commit secrets to version control
- Rotate secrets regularly

## Conclusion

Following Python best practices leads to code that is:
- Easier to read and understand
- Easier to maintain and debug
- More reliable and secure
- More performant

Remember: "Readability counts" - The Zen of Python
